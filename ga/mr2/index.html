<!--
	Mystery: somehow "name" === "r"

	TODO for world map
		Mapping from angles to texture coords, probably based in the thing
		Slicing system that allows you to see a sliced-open globe
		mappings/arrays
		Scalars, certainly ones that can be seen as angles
		+, cos, sin, exp, in pad.js
		A lot of it is about projection. Sending projection point to infinity

	Fun GA things probably unnecessary to world map so avoid:
		plane, pss
		dual, join






	After
		Videos about projective geometry
		Demo of features of this thing
		omicron reduction
		Draw curve, get curve as usable thing. Killer app!
		Transpiling to javascript
		If you're serious about people making clothes, think about makeup tutorials
		transpile to glsl first and foremost. Whole game runs in every shader woo!
-->
<html>
	<head>
		<title>mr2</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script>
			async function technicalInit() {
				let renderEverything = initRenderFunctions()

				initAlgebra()

				initPremadeBuffers()
				
				initButtons()
				initMouse()
				initWindowResizeSystem()

				initNamesAndBasis()

				initMvAppearances()

				if(0)
				{
					function Node(lexeme, parent, indexInParent) {
						this.lexeme = lexeme
						this.children = []

						this.parent = parent
						if(parent !== null)
							parent.addChild(this, indexInParent)

						if(lexeme === "")
							this.expectedNumberOfChildren = 1
						else if( orderedNames.indexOf(lexeme) !== -1 )
							this.expectedNumberOfChildren = 0
						else if(functionNames.indexOf(lexeme) === -1) 
							this.expectedNumberOfChildren = eval(lexeme).length
						else
							console.error("unrecognized lexeme: ", lexeme)
					}
					Node.prototype.addChild = (child, replacementIndex) => {
						let index = replacementIndex || this.children.length
						this.children[replacementIndex] = child
						child.parent = this
					}

					let topNode = new Node("", null)
					let currentNode = topNode
					let branchCanComplete = false
					let skipFrom = Infinity

					function adjustToOpenBracket(functionLexeme) {
						branchCanComplete = false
						let newNode = new Node(functionLexeme, currentNode)
						currentNode = newNode
					}
					function adjustToInfixNode(infixLexeme) {
						if (currentNode === topNode) {
							console.error("shouldn't be here")
							skipFrom = i
						}

						let parent = currentNode.parent
						let indexInParent = parent.children.indexOf(currentNode)

						let infixFunctionNode = new Node(infixLexeme, parent, indexInParent)
						infixFunctionNode.addChild(currentNode)
						currentNode = infixFunctionNode
					}

					for (let i = 0; i < tokenArray.length && skipFrom === Infinity; ++i) {
						let isMv = orderedNames.indexOf(lexeme) !== -1
						let isFunction = functionNames.indexOf(lexeme) !== -1
						let isOpenBracket = lexeme === "("

						if (isMv || isFunction || isOpenBracket) {
							if(branchCanComplete)
								adjustToInfixNode("gp")
							
							if (isMv) {
								let newNode = new Node(lexeme, currentNode)
								branchCanComplete = true
							}
							else if (isFunction && tokenArray[i + 1] === "(") {
								adjustToOpenBracket(lexeme)
								++i
							}
							else if (isOpenBracket)
								adjustToOpenBracket("")
							else
								skipFrom = i
						}
						else if (branchCanComplete) {
							if (lexeme === "," && currentNode.children.length !== currentNode.expectedNumberOfChildren)
								branchCanComplete = false
							else if (lexeme === ")" && currentNode.children.length === currentNode.expectedNumberOfChildren)
								currentNode = currentNode.parent //we move up having finished branch, so this branch is potentially valid too
							else if (lexeme === "+") {//or other infixes
								adjustToInfixNode("+")
								branchCanComplete = false
							}
							else {
								if (lexeme === "," || lexeme === ")")
									console.error("too few arguments")
								skipFrom = i
							}
						}
					}
					if(!branchCanComplete)
						skipFrom = tokenArray.length

					function parse(node) {
						let str = node.lexeme
						if(node.children.length > 0 ) {
							str += "("
							node.children.forEach((child, childIndex) => {
								str += (childIndex === 0 ? "" : ",") + parse(child)
							})
							str += ")"
						}
						return str
					}
					let finalString = parse(topNode)
					log(finalString)
				}

				return

				// await initWorldMap()
				// await initDymaxion()

				// initDebugPad()

				await initPad()

				function loop() {
					mouse.updateFromAsyncAndCheckClicks()

					for(var i = 0; i < updateFunctions.length; i++)
						updateFunctions[i]()

					renderEverything()

					++frameCount

					setTimeout(() => {
						requestAnimationFrame(loop)
					}, 1000./60.);
				}

				loop()
			}
		</script>

		<script src="../common/variables.js"></script>
		<script src="variables.js"></script>
		

		<script src="shaderUtils.js"></script>

		<script src="../common/buttons.js"></script>

		<script src="windowResizeSystem.js"></script>

		<script src="names.js"></script>

		<script src="text.js"></script>
		

		<script src="pad.js"></script>
		<script src="compiler.js"></script>

		<script src="textureSampler.js"></script>

		<script src="caratAndKeyboard.js"></script>

		<script src="renderFunctions.js"></script>

		<script src="maps.js"></script>

		<script src="algebra.js"></script>
		<script src="frames.js"></script>

		<script src="miscGl.js"></script>

		<script src="displays.js"></script>

		<script src="colors.js"></script>

		<script src="names.js"></script>

		<script src="mouse.js"></script>

		<script src="mvAppearances.js"></script>

		<script src="funcViz.js"></script>

		<script src="miscFunctions.js"></script>

		<script src="displayWindows.js"></script>

		<script src="drawing.js"></script>

		<script src="vertBufferFunctions.js"></script>

		<!-- <script src="video.js"></script> -->
		

		<script>
			technicalInit()
		</script>
	</body>
</html>