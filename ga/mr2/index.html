<!--
	Mkay just something to try out: 
		arrows, and when you edit them, they're on surface of sphere
		useful for globe?

	TODO
		Arrows for directions
		Highlight multiple lines to make it all appear in hovering dw
		Fucking which way is z
		Bug with your mind: you want to reinvent calculus. Just wait for calculus shit to come up then ask people how to do it

		Pros:
			Can see and touch the things in front of you
			Specify points on the globes in 3D
		Cons: Keyboard is useful for:
			changing the name of a globe
	Maybe... the lines of code create an animation, step through it using your cursor
		Or, you have certain lines where you display what's in each frame of the animation, then ctrl up and down to get between them
		If you know how the value was derived, you know what tweening animation to have? Professionalism is all just tweening
		Well you want to be able to make things gesturally, Bret style, right? Animations simulate that

	Filming setup
		Remember, every word a piece of origami!
		Semi transparent background to pad
		Nice camera
		Go from relevant line to relevant line. Sounds like you're cutting stuff out though

	Hey, could have "cartesian product" symbol, mathematicians would like you
		Or tensor product
		f x g = {(x,y) : there exists A,B s.t. f(A), g(B) }
		Or, ordinary javascript arrays
		But this isn't about arrays it's about functions

	General/universal visual algebra
		New algebra for every video
		you have a way of defininig literals. Strings (bits really but strings do)
		you have functions defined on that algebra
		Sometimes you want different viz for different things. Real view, disc view, color view
		So you have your algebra, you have your visualizations
			And for one visualization, you can change is algebraic, er, significance. I.e. its type?
				Eg arrow left arrow up. Add the arrows.
					If they're PGA elements, you get the point inbetween.
					If LA elements, get the arrows concatenated
			And for one type / algebraic structure, you can change its visualization
				Eg crowd of people
					The visualization of the people
					The number of them that are infected
			Pong game states are an algebraic structure, with only maybe 3 dimensions
	

	Interested parties
		Language people: Alan, Meurig, Martin, futureOfCoding, Yoshiki, Cynthia Solomon, Andy Matuschak, Katherine Ye, Glench, Ken Perlin, Josh Horowitz, 
		GAists: bivector discord, Cam folks, Charles Gunn, Steven Der kenick, Pierre Philipp Denchant, Jonathan Cameron,Â David Hestenes, Paul Simeon
		Graphics/gamedev: Keenan Crane, Albert Chern, Fabrice, Haxiomic, Dan Holden, Daniel Piker, Ian and Norgg, Media Molecule, Chris Deleon, Senthuran
		Math/physicist: Ivan and Nina, Florian, Eric stansifer, Matt Hare
		Misc: London Rationalish, 
		Youtubers: Code parade, sebastian lague, inigo quilez, Ben Eater, Coding Train guy, Grant sanderson

	After
		Back to basics, you want to make a thing
		Videos about projective geometry
		Oi, "demonstrations" / footage. Classical mechanics. But better to wait for built in AR?
		Demo of features of this thing
		omicron reduction
		"A different way to visualize calculus" - there's a lot of fun to be had with weird algebras (SR, QC) before you get to this
		Draw curve, get curve as usable thing. Killer app!
		Music video https://www.youtube.com/watch?v=wfkid5mpgWI
			first stanzas are making little machines
			Then you're setting up loops, like a conductor
		Convert to single visualization (for Brilliant)
		If you're serious about people making clothes, think about makeup tutorials
		transpile to glsl first and foremost. Whole game runs in every shader woo!
		Eventually: VR game with conformal transformations. To help build folks' intuition? No! Because they're fun!
-->
<html>
	<head>
		<title>Unrig</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script>
			async function technicalInit() {
				let renderEverything = initRenderFunctions()

				initButtons()
				let loadedJson = await loadBackgroundStringAndInitSave()
				initWindowResizeSystem()
				
				initTextboxes()
				
				initAlgebra()

				initPremadeBuffers()

				initMouse()

				// await initWorldMap()

				initNames()
				initPictogramDrawers()
				initMvPictograms()
				// debugger
				await initGlobePictograms()

				initFunctionWithIrs()

				initCarat()

				initCharacterTexture()

				initEvaluate()

				await initTextureSampler()
				initFrames()

				initDisplayWindows()

				{
					loadedJson.freeMvNames.forEach((name, i) => {
						assignMv(name)
						for (let j = 0; j < 16; ++j)
							getNameDrawerProperties(name).value[j] = loadedJson.freeMvValues[i][j]
					})

					assignTypeAndData("bg", "angle", { value: .5 })
					assignTypeAndData("r", "slider", { value: 0. })

					assignTypeAndData("o", "test",   { value: 0. })

					//basis
					{
						//angle between our normal vectors and z axis (pointing towards us) is ti
						let angleToZAxis = Math.acos(1. / Math.sqrt(3.))
						let z = Math.cos(angleToZAxis)
						let triangleRadius = Math.sin(angleToZAxis)
						assignMv("bw")
						plane(getNameDrawerProperties("bw").value, 0., triangleRadius, z, 0.);
						assignMv("op")
						plane(getNameDrawerProperties("op").value,-HS3 * triangleRadius, -.5 * triangleRadius, z, 0.);
						assignMv("or")
						plane(getNameDrawerProperties("or").value, HS3 * triangleRadius, -.5 * triangleRadius, z, 0.);

						//and ow for the e0 plane
					}

					let textureNames = ["earthColor", "ball", "cmb", "jupiter", "latAndLon2"]
					for (let i = 0; i < textureNames.length; ++i) {
						let texture = await Texture("data/" + textureNames[i] + ".png")
						assignTypeAndData(coloredNamesAlphabetically[13 + i], "globe", {texture})
						//this could compile to glsl, it's a struct
					}
				}

				// await initDymaxion()

				function loop() {

					mouse.updateFromAsyncAndCheckClicks()

					tokenizeEvaluateDrawTokens()

					for(let i = 0; i < updateFunctions.length; i++)
						updateFunctions[i]()

					renderEverything()

					++frameCount

					setTimeout(() => {
						requestAnimationFrame(loop)
					}, 1000./60.);
				}

				loop()
			}
		</script>

		<script src="../common/variables.js"></script>
		<script src="variables.js"></script>
		

		<script src="shaderUtils.js"></script>

		<script src="pictogramDrawers.js"></script>

		<script src="slider.js"></script>

		<script src="../common/buttons.js"></script>

		<script src="windowResizeSystem.js"></script>

		<script src="text.js"></script>
		
		<script src="tokenize.js"></script>
		<script src="evaluate.js"></script>
		<script src="drawTokens.js"></script>
		<script src="errorHighlight.js"></script>

		<script src="textureSampler.js"></script>

		<script src="caratAndKeyboard.js"></script>

		<script src="renderFunctions.js"></script>

		<script src="maps.js"></script>
		<script src="mapsIntegrated.js"></script>

		<script src="algebra.js"></script>
		<script src="dualQuaternions.js"></script>

		<script src="miscGl.js"></script>

		<script src="displays.js"></script>

		<script src="colors.js"></script>

		<script src="mouse.js"></script>

		<script src="names.js"></script>

		<script src="frames.js"></script>
		<script src="mvAppearances.js"></script>

		<script src="funcViz.js"></script>

		<script src="miscFunctions.js"></script>
		<script src="screenPosition.js"></script>

		<script src="displayWindows.js"></script>

		<script src="vertBufferFunctions.js"></script>

		<script src="transpiler.js"></script>
		<script src="transpiledFunctions.js"></script>

		<script src="ClickableTextboxes.js"></script>

		<script src="toolbar.js"></script>

		<!-- <script src="video.js"></script> -->
		

		<script>
			technicalInit()
		</script>
	</body>
</html>