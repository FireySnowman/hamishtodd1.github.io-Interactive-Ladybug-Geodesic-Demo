<!-- Godel's bulldog logo: start with line inside circle, go to circle inside line -->

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<!-- <script src="/socket.io/socket.io.js"></script>
		<script src="connection.js"></script> -->

		<script src="lib/three.js"></script>
		<script src="lib/sceneUtils.js"></script>

		<script src="lib/OBJLoader.js"></script>

		<script src="lib/WebVR.js"></script>

		
		<script src="vr.js"></script>

		<script src="lighting.js"></script>
		<script src="helmet.js"></script>

		<script src="mockVrInput.js"></script>

		<script src="face.js"></script>

		<script src="recordingAndPlayback.js"></script>
		<script src="cameraHolder.js"></script>
		
		<script src="text.js"></script>

		<script src="keyboard.js"></script>

		<script src="visibox.js"></script>
		<script src="surroundings.js"></script>
		
		<script src="miscFunctions.js"></script>
		<script src="variables.js"></script>

		<script src="picsAndVideos.js"></script>

		<script src="juggling.js"></script>
		
		<script src="mouse.js"></script>

		<!-- <script src="units/mobiusTransformations.js"></script> -->

		<script src="units/shaderExperimentation.js"></script>
		<!-- <script src="units/maps.js"></script> -->

		<!-- <script src="units/fish.js"></script> -->
		<!-- <script src="units/threeSphereExploration.js"></script>
		<script src="units/twoSphereExploration.js"></script> -->

		<!-- <script src="units/scalarFieldVisualization.js"></script> -->

		<!-- <script src="units/icerm.js"></script> -->

		<!-- <script src="units/turing.js"></script> -->
		<!-- <script src="units/grayScott.js"></script>
		<script src="units/fitzhughNagumo.js"></script>
		<script src="units/barkley.js"></script> -->

		<!-- <script src="units/escher.js"></script>

		<script src="units/dynamicalSystems.js"></script>

		<script src="units/simulation.js"></script> -->

		<script>
			async function init()
			{
				let canvas = document.createElement( 'canvas' );
				let gl = canvas.getContext( 'webgl2' );
				console.assert(gl !== null )
				renderer = new THREE.WebGLRenderer( { canvas: canvas, context: gl,antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.localClippingEnabled = true;
				document.body.appendChild( renderer.domElement );

				if(MODE !== VR_TESTING_MODE)
				{
					let windowResize = function()
					{
						renderer.setSize( window.innerWidth, window.innerHeight );
						camera.aspect = window.innerWidth / window.innerHeight; //so the sides may be cut off
						camera.updateProjectionMatrix();
					}
					window.addEventListener( 'resize', windowResize)
				}

				initMouse()
				initButtons()
				initFaceMaker()
				initLights()
				// await initPlaybackAndRecording()			
				initControllerObjects()
				if( MODE !== PLAYBACK_MODE )
				{
					await initFloorAndSky()
					var getVrOrMockVrInput = initVrOrMockVrInput()
				}

				// await initMaps();

				// await initFitzhughNagumo(gl)
				// initDynamicalSystems()

				// await initEscher()

				// await initShaderExperimentation( gl )
				// await initTuring(gl)
				// await initIcerm(gl);
				// await initBarkley(gl)
				// await initBasicSimulation()
				// await initScalarFieldVisualization();
				// await initLayeredSimulation()

				{
					let viz = new THREE.Group()
					scene.add(viz)

					let littleScene = new THREE.Group()
					viz.add(littleScene)

					let spacecraft = new THREE.Mesh(new THREE.PlaneBufferGeometry(.1, .1), new THREE.MeshBasicMaterial({ transparent: true }))
					littleScene.add(spacecraft)
					let loader = new THREE.TextureLoader().setCrossOrigin(true)
					loader.load("data/spacecraft.png", function (texture)
					{
						spacecraft.material.map = texture
						spacecraft.material.needsUpdate = true
					}, function () { }, function (e) { console.error(e) })

					let tube = new THREE.Mesh(new THREE.CylinderBufferGeometry(.01, .01), new THREE.MeshBasicMaterial({
						color: 0xFFFFFF,
						transparent: true,
						opacity: 0.3
					}))
					tube.geometry.rotateZ(TAU / 4.)
					littleScene.add(tube)

					let bulbObj = null
					await new Promise(resolve =>
					{
						objLoader = new THREE.OBJLoader()
						objLoader.load("data/Lamp_Fluorescent_Illuminated.obj", function (obj)
						{
							bulbObj = obj
							resolve()
						}, function () { }, function (e) { console.log(e) })
					})
					function Bulb()
					{
						let bulb = new THREE.Group()

						littleScene.add(bulb)
						bulb.scale.multiplyScalar(0.0005)

						let bottom = bulbObj.children[0]
						bulb.add(new THREE.Mesh(bottom.geometry, new THREE.MeshStandardMaterial({
							color: 0x000000
						})))

						let bowlGeo = new THREE.Geometry().fromBufferGeometry(bulbObj.children[1].geometry)
						bowlGeo.mergeVertices()
						bowlGeo.computeFaceNormals()
						bowlGeo.computeVertexNormals()
						bulb.add(new THREE.Mesh(bowlGeo, new THREE.MeshLambertMaterial({
							color: 0xFFFFFF
						})))

						let screw = bulbObj.children[4]
						bulb.add(new THREE.Mesh(screw.geometry, new THREE.MeshStandardMaterial({ color: 0xCCCCCC })))

						bulb.lightBit = new THREE.Mesh(
							bulbObj.children[2].geometry.merge(bulbObj.children[3].geometry),
							new THREE.MeshLambertMaterial({ color: 0xFFFFFF }))
						bulb.add(bulb.lightBit)

						for (let i = 0; i < bulb.children.length; i++)
							bulb.children[i].position.y -= 90

						return bulb
					}

					let mouseLineInLittleScene = new THREE.Line3()
					let intersectionPlane = new THREE.Plane()
					intersectionPlane.normal.set(0., 0., 1.)
					intersectionPlane.constant = -.5

					littleScene.position.z = .5
					updateFunctions.push(() =>
					{
						if (mouse.clicking)
						{
							mouseLineInLittleScene.start.copy(mouse.rayCaster.ray.origin)
							mouseLineInLittleScene.end.copy(mouse.rayCaster.ray.direction).add(mouse.rayCaster.ray.origin)
							viz.worldToLocal(mouseLineInLittleScene.start)
							viz.worldToLocal(mouseLineInLittleScene.end)

							if (null === intersectionPlane.intersectLine(mouseLineInLittleScene, v1))
								log("no intersection")

							littleScene.position.copy(v1)
							littleScene.position.x = 0.

							littleScene.position.y = clamp(littleScene.position.y, -.5, .5)
						}

						littleScene.position.z -= .003 //advance time
						if (littleScene.position.z < -.5)
							littleScene.position.z = -.5

						let time = .5 - littleScene.position.z
						let velocity = littleScene.position.y
						spacecraft.position.x = time * velocity //top speed is .5 per 1, so half the speed of light
						
						let closestDist = Infinity
						let vertexIndex = -1
						for (let j = 0; j < bulbs[0].lines[0].geometry.vertices.length; j++)
						{
							let dist = Math.abs(bulbs[0].lines[0].geometry.vertices[j].y - velocity)
							if (dist < closestDist)
							{
								vertexIndex = j
								closestDist = dist
							}
						}

						for (let i = 0, il = bulbs.length; i < il; ++i)
						{
							let col = 0x808080
							
							//if flash duration seems too long or short it's because .1 needs to be lorenz adjusted, duh! really there are two events, on and off
							let timeRadius = .01
							for (let j = 0, jl = bulbs[i].lines.length; j < jl; ++j)
							{
								let dist = Math.abs(bulbs[i].lines[j].geometry.vertices[vertexIndex].z - littleScene.position.z)
								if (dist < timeRadius)
									col = 0xFFFFFF
							}

							//contraction! when lines are curved bulbs will need to move too
							// bulbs[i].positionS

							v1.copy(bulbs[i].position).add(littleScene.position)

							bulbs[i].lightBit.material.color.setHex(col)
						}
					})

					let divisions = 7;
					let bulbs = Array(divisions + 1)
					for(let i = 0; i <= divisions; ++i)
					{
						let spacePosition = -.5 + i / divisions //it gets i because the bulbs are an array
						bulbs[i] = Bulb()
						bulbs[i].position.x = spacePosition
						bulbs[i].lines = []
						littleScene.add(bulbs[i])
						for(let j = 0; j <= divisions; j++)
						{
							let timePosition  = -.5 + j / divisions

							let mat = new THREE.MeshBasicMaterial({ color:0xFF0000})
							let l = new THREE.Line(new THREE.Geometry(), mat)
							bulbs[i].lines.push(l)
							for (let k = 0; k <= divisions; k++)
							{
								let rfPosition = -.5 + k / divisions
								let v = new THREE.Vector3(spacePosition, rfPosition, timePosition)
								l.geometry.vertices.push(v)
							}
							viz.add(l)
						}
					}
					viz.scale.setScalar(.2)
					viz.position.z = -.5
					viz.position.y = 1.6

					viz.rotation.y += -TAU/8.
					viz.rotation.x += TAU / 8.
				}

				renderer.setAnimationLoop( function()
				{
					frameDelta = clock.getDelta()

					mouse.updateFromAsyncAndCheckClicks()

					if( MODE !== PLAYBACK_MODE )
						getVrOrMockVrInput()

					callContingentUpdateFunctionsAndMaybeRecordOrSynchronizeToVideo()
					
					for(let i = 0; i < alwaysUpdateFunctions.length; i++)
						alwaysUpdateFunctions[i]()

					ourRender()

					frameCount++;
				})
			}
			init()
		</script>
	</body>
</html>